## 数组（折半查找，插值查找，斐波那契查找
> 内存中连续存储的多个数据
> 内存空间分配是连续的
 
#### 使用索引操作
* 查询数据：会先得到数组的首地址，通过索引乘以对应数据的长度就得到了该数据的索引，直接取到数据
* 修改数据：通过查询直接覆盖该地址
* 新增数据：因为数据在内存中的存放是连续的，所以新增数据时无法保证新增的地址是否已经存在数据，所以在编程语言中数组数据一旦声明，其长度一定是固定的，如果需求一定要新增的化，就创建一个长度更长的新的数组。
* 删除数据：同样因为数组是连续的，那么一旦删除非末尾的元素，那么其后的元素都要向前移动一位以保证连续性

> 可以看出数组的新增和删除是非常消耗系统资源的。声明数组前尽量保证该数据会尽可能少的用到新增和删除操作

## 栈
> 线性表实现
> 栈顶允许操作，栈底不允许操作
> 只能添加(压栈/入栈)和删除(弹栈/出栈)，不能修改
> 多个数据存储时，遵循先进后出，后进先出原则

使用场景如日志处理，对时间线依次追加进去，取出则依次回退每天的数据；函数的局部变量，虽则函数的调用，频繁的进行新增和删除操作。

ps：内存中的栈和数据结构中的栈不是一个东西。
内存中的栈由操作系统自动分配释放，存放函数的参数值，局部变量等，其操作类似于数据结构中的栈。Js中所有基本类型存在栈
内存中的堆由程序员自自己分配释放，如果程序员不做此操作，则等待程序结束，系统自动回收。Jsc中所有引用类型存在堆中，且Js处理器会自动帮我们释放未被引用的对象。

> 使用栈可以进行快速的加载读取，同时处理都是在栈中处理，不会产生内存碎片的问题。


## 队列
> 线性表的实现
> 先进先出，后进后出原则

队列中分为队首和队尾，分别为其分配前置计数器，和后置计数器，数据从队尾增加，从队首取出
添加新数据时后置计数器自增（数据长度等于后置计数器+1-前置计数器），移除数据时前置计数器自增，当前置计数器的引用等于后置计数器时说明该队列是一个空队列。
当有数据被移除时如同数组的操作，所有数据向前移动，回到队首。因为底层使用数组操作，所以还是比较消耗系统性能。

### 循环队列
队尾的位置会从新指向队首，由前置计数器和后置计数器来判断队列首末，其解决了数据平移所带来的性能损耗。

## 链表（通过树提升查找效率
> 非连续，非顺序的存储结构
> 数据逻辑顺序由指针指向
> 根据指针的不同功能链表分为单向列表，循环列表和双向列表

由于其根据指针遍历，数据查询都需要从链表头部开始，一旦数据量变大，那么查询效率就会有所影响（树解决了该问题）
Java在数据处理量大时推荐使用链表操作，如果不是数组操作就可以了，其相差是不大的

## 树
> 底层通过链表或者散列表组成
> 最典型应用：二叉树

## 散列表Hash表（基于数组和链表）
> 根据key，value直接访问数据结构

在构建时会创建一个基于数组的散列堆，每当存入一个数据时，会先对数据进行哈希处理，得到哈希值，再通过hash值存入以对应的散列堆为首部的链表中，在处理中有可能会出现哈希碰撞的情况，不同的哈希值取余出一样的散列堆，那么就依次链接在上一个数据的next指针上
使用这种数据结构，基于数组的散列堆可以帮助我们快速的去定位数据所存在的位置，再通过链表快速的进行删除或增加操作，一旦链表数据量庞大可以通过一些排序算法进行快速的定位数据在链表中的位置

## 图
> 是一些顶点和边的组合
> 链表和树都是最简单的图

图在处理过程中通过边关联多个处理数据，通过权重关联数据检索的复杂度
底层实现上通过散列表和数据记录，用于解决更加复杂的数据关联关系


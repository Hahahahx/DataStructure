## 算法的时间复杂度
假设每行代码的执行时间为t，那么

```Java
  int sunFunc(int n){   
    int num = 0;  //执行一次
    for (int i = 0; i<n; i++){  //执行n次
      num = num + i;  //执行n次
    }
    return num; //执行一次
  }
```

这块代码执行的时间就是(2n+2)*t，同样

```Java
    int sunFunc(int n){
        int num = 0; //执行一次
        for(int i = 0; i<n; i++){   //执行n次
            for(int j = 0; j<n; j++){   //执行n*n次
                num = num + i * j;  //执行n*n次
            }
        }
        return num; //执行一次
    }
```

这块代码执行的时间就是(2n^2+n+2)*t。

在数据结构算法中，通常使用T(n)表示代码执行时间，n表示数据规模大小，f(n)表示代码执行次数综合，所以上面的例子可以表示为**f(n) = (2n^2+n+2)*t**。

O表示代码执行时间与f(n)成正比，也就是**代码执行时间T(n)与每行代码的执行次数n成正比**，T(n)=O(f(n))。

所以第一个例子中**T(n)=O(2n+2)**，第二个例子中**T(n)=O(2n^2+n+2)**，这就是时间复杂度表示法，也叫大O时间复杂度表示法。

***但是***，大O的时间复杂度并不是代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以也叫**渐进时间复杂度**。

